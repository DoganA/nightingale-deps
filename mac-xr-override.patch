diff --git a/xulrunner-1.9.2/mozilla/toolkit/xre/MacApplicationDelegate.mm b/xulrunner-1.9.2/mozilla/toolkit/xre/MacApplicationDelegate.mm
index 3f29c3b..5ea9764 100644
--- a/xulrunner-1.9.2/mozilla/toolkit/xre/MacApplicationDelegate.mm
+++ b/xulrunner-1.9.2/mozilla/toolkit/xre/MacApplicationDelegate.mm
@@ -64,6 +64,10 @@
 #include "nsDirectoryServiceDefs.h"
 #include "nsICommandLineRunner.h"
 
+#define ABOUT_MENUITEM_ID         1
+#define PREFERENCES_MENUITEM_ID   2
+#define QUIT_MENUITEM_ID          3
+
 class AutoAutoreleasePool {
 public:
   AutoAutoreleasePool()
@@ -80,8 +84,20 @@ private:
 
 @interface MacApplicationDelegate : NSObject
 {
+  BOOL mIsSimulatingModalSession;
+  id   mAppDelegateOverride;
 }
 
+- (void)setAppDelegateOverride:(id)aDelegateOverride;
+
+@end
+
+@interface MacApplicationDelegate (Private)
+
+- (void)onBeginGeckoModalSession:(id)sender;
+- (void)onEndGeckoModalSession:(id)sender;
+- (void)configureAppMenu:(BOOL)inIsModal;
+
 @end
 
 // Something to call from non-objective code.
@@ -143,6 +159,17 @@ SetupMacApplicationDelegate()
                andSelector:@selector(handleAppleEvent:withReplyEvent:)
              forEventClass:kCoreEventClass
                 andEventID:kAEOpenDocuments];
+
+    mAppDelegateOverride = nil;
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(onBeginGeckoModalSession:) 
+                                                 name:@"GeckoStartModal" 
+                                               object:nil];
+
+    [[NSNotificationCenter defaultCenter] addObserver:self 
+                                             selector:@selector(onEndGeckoModalSession:) 
+                                                 name:@"GeckoEndModal" 
+                                               object:nil];
   }
   return self;
 
@@ -157,11 +184,17 @@ SetupMacApplicationDelegate()
   [aeMgr removeEventHandlerForEventClass:kInternetEventClass andEventID:kAEGetURL];
   [aeMgr removeEventHandlerForEventClass:'WWW!' andEventID:'OURL'];
   [aeMgr removeEventHandlerForEventClass:kCoreEventClass andEventID:kAEOpenDocuments];
+  [[NSNotificationCenter defaultCenter] removeObserver:self];
   [super dealloc];
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
+- (void)setAppDelegateOverride:(id)aDelegateOverride
+{
+  mAppDelegateOverride = aDelegateOverride;
+}
+
 // Opening the application is handled specially elsewhere,
 // don't define applicationOpenUntitledFile: .
 
@@ -172,6 +205,12 @@ SetupMacApplicationDelegate()
 // nsCocoaNativeReOpen() if 'flag' is 'true'.
 - (BOOL)applicationShouldHandleReopen:(NSApplication*)theApp hasVisibleWindows:(BOOL)flag
 {
+  if (mAppDelegateOverride && 
+      [mAppDelegateOverride respondsToSelector:@selector(applicationShouldHandleReopen:hasVisibleWindows:)])
+  {
+    return [mAppDelegateOverride applicationShouldHandleReopen:theApp hasVisibleWindows:flag];
+  }
+
   nsCOMPtr<nsINativeAppSupport> nas = do_CreateInstance(NS_NATIVEAPPSUPPORT_CONTRACTID);
   NS_ENSURE_TRUE(nas, NO);
 
@@ -252,6 +291,12 @@ static NSWindow* GetCocoaWindowForXULWindow(nsISupports *aXULWindow)
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 
+  if (mAppDelegateOverride &&
+      [mAppDelegateOverride respondsToSelector:@selector(applicationDockMenu:)]) 
+  {
+    return [mAppDelegateOverride applicationDockMenu:sender];
+  }
+
   // Why we're not just using Cocoa to enumerate our windows:
   // The Dock thinks we're a Carbon app, probably because we don't have a
   // blessed Window menu, so we get none of the automatic handling for dock
@@ -284,6 +329,13 @@ static NSWindow* GetCocoaWindowForXULWindow(nsISupports *aXULWindow)
 
   // Iterate through our list of windows to create our menu
   NSMenu *menu = [[[NSMenu alloc] initWithTitle:@""] autorelease];
+
+  // If we are currently running a gecko modal session, this item 
+  // needs to be disabled.
+  if (mIsSimulatingModalSession) {
+    [menu setAutoenablesItems:NO];
+  }
+
   PRBool more;
   while (NS_SUCCEEDED(windowList->HasMoreElements(&more)) && more) {
     // Get our native window
@@ -308,6 +360,9 @@ static NSWindow* GetCocoaWindowForXULWindow(nsISupports *aXULWindow)
     if (SameCOMIdentity(xulWindow, frontWindow))
       [menuItem setState:NSOnState];
 
+    if (mIsSimulatingModalSession)
+      [menuItem setEnabled:NO];
+
     [menu addItem:menuItem];
     [menuItem release];
   }
@@ -420,4 +475,25 @@ static NSWindow* GetCocoaWindowForXULWindow(nsISupports *aXULWindow)
   }
 }
 
+- (void)onBeginGeckoModalSession:(id)sender
+{
+  mIsSimulatingModalSession = YES;
+  [self configureAppMenu:YES];
+}
+
+- (void)onEndGeckoModalSession:(id)sender
+{
+  mIsSimulatingModalSession = NO;
+  [self configureAppMenu:NO];
+}
+
+- (void)configureAppMenu:(BOOL)inIsModal
+{
+  NSMenu *menu = [[[NSApp mainMenu] itemAtIndex:0] submenu];
+  [menu setAutoenablesItems:!inIsModal];
+  [[menu itemWithTag:ABOUT_MENUITEM_ID] setEnabled:!inIsModal];
+  [[menu itemWithTag:PREFERENCES_MENUTITEM_ID] setEnabled:!inIsModal];
+  [[menu itemWithTag:QUIT_MENUITEM_ID] setEnabled:!inIsModal];
+}
+
 @end
